# Document Operator

Сервис для работы с документами: создание, отправка на согласование и утверждение. Поддерживает массовую генерацию документов и фоновую обработку пачками.

---

## Запуск сервиса

### 1. Поднять базу данных

Перед запуском приложения необходимо поднять PostgreSQL с помощью Docker Compose:

```bash
docker-compose up -d
```

Будет запущена БД:
- **Порт:** 5432
- **База:** `document_operator`
- **Пользователь / пароль:** `postgres` / `postgres` (при необходимости можно переопределить через переменные окружения в `application.yml`).

### 2. Запустить приложение

После старта БД запустите приложение обычным способом (например, через IDE или Maven):

```bash
mvn spring-boot:run
```

Сервис по умолчанию доступен на порту **8080**.

---

## Переменные окружения (application.yml)

Настройки можно менять через переменные окружения (env). Ниже перечислены все используемые переменные и их назначение.

### Сервер и порт

| Переменная | Описание | Значение по умолчанию |
|------------|----------|------------------------|
| `PORT` | Порт HTTP-сервера приложения | `8080` |

### База данных

| Переменная | Описание | Значение по умолчанию |
|------------|----------|------------------------|
| `DB_USER` | Пользователь PostgreSQL | `postgres` |
| `DB_PASS` | Пароль PostgreSQL | `postgres` |

> **Примечание:** URL БД в конфиге захардкожен как `jdbc:postgresql://localhost:5432/document_operator`. Для смены хоста/порта нужно править `spring.datasource.url` в `application.yml`.

### Воркеры (фоновые задачи)

| Переменная | Описание | Значение по умолчанию |
|------------|----------|------------------------|
| `ENABLE_SUBMIT` | Включить воркер отправки на согласование (DRAFT → SUBMITTED) | `true` |
| `ENABLE_APPROVE` | Включить воркер утверждения (SUBMITTED → APPROVED) | `true` |
| `DOCUMENT_OPERATOR_BATCH_SIZE` | Размер пачки документов при обработке воркерами | `10` |
| `DOCUMENT_OPERATOR_WORKER_SUBMIT_INTERVAL_MS` | Интервал между запусками воркера отправки на согласование (мс) | `500000` |
| `DOCUMENT_OPERATOR_WORKER_APPROVE_INTERVAL_MS` | Интервал между запусками воркера утверждения (мс) | `500000` |

### Генератор документов

Используются при вызове API запуска генератора (например, `POST /api/generator/run`):

| Переменная | Описание | Значение по умолчанию |
|------------|----------|------------------------|
| `TOTAL_DOCUMENTS` | Сколько документов создавать за один запуск генератора | `20` |
| `AUTHOR_PREFIX` | Префикс автора документа (к нему добавляется индекс) | `user` |
| `TITLE_PREFIX` | Префикс названия документа | `Document` |
| `DOC_GEN_BATCH_SIZE` | Размер пачки при создании документов генератором | `10` |

---

## Утилиты (фоновые задачи / jobs)

Под «утилитой» здесь понимаются фоновые задачи (воркеры), которые периодически обрабатывают документы пачками:

1. **Submit** — переводит документы из статуса DRAFT в SUBMITTED (отправка на согласование).
2. **Approve** — переводит документы из статуса SUBMITTED в APPROVED (утверждение).

### Включение и отключение

Управление воркерами выполняется переменными окружения:

- **Включить только отправку на согласование** (без утверждения):
  ```bash
  set ENABLE_SUBMIT=true
  set ENABLE_APPROVE=false
  ```
  (В Linux/macOS: `export ENABLE_SUBMIT=true` и `export ENABLE_APPROVE=false`.)

- **Включить только утверждение** (без отправки на согласование):
  ```bash
  set ENABLE_SUBMIT=false
  set ENABLE_APPROVE=true
  ```

- **Включить оба воркера** (значение по умолчанию):
  ```bash
  set ENABLE_SUBMIT=true
  set ENABLE_APPROVE=true
  ```

- **Отключить оба** (только API и ручная работа с документами):
  ```bash
  set ENABLE_SUBMIT=false
  set ENABLE_APPROVE=false
  ```

После установки переменных перезапустите приложение. Соответствующие бины воркеров создаются только при `true`, при `false` запланированные задачи не регистрируются и не выполняются.

### Как это устроено

- При `ENABLE_SUBMIT=true` раз в `DOCUMENT_OPERATOR_WORKER_SUBMIT_INTERVAL_MS` миллисекунд запускается задача: выбирается до `DOCUMENT_OPERATOR_BATCH_SIZE` документов в статусе DRAFT и переводится в SUBMITTED.
- При `ENABLE_APPROVE=true` раз в `DOCUMENT_OPERATOR_WORKER_APPROVE_INTERVAL_MS` миллисекунд выбирается до `DOCUMENT_OPERATOR_BATCH_SIZE` документов в статусе SUBMITTED и переводится в APPROVED.

Используемые настройки (интервалы и размер пачки) описаны в таблице переменных выше.


ОПЦИОНАЛЬНО:

1. Обработка одного запроса с 5000+ ID
   Сейчас: в DocumentServiceImpl.submitDocuments и approveDocuments идёт цикл по списку ID, для каждого вызывается documentWorkflowService.submitDocument(id) / approveDocument(id) — отдельная транзакция и обращение к БД на каждый документ. При 5000 ID это даёт 5000 транзакций и много круг trip’ов.
   Что бы я поменял:
   Пакетная обработка в БД
   Вместо «for each id → load → change → save» делать один запрос (или несколько пачками) по множеству ID:
   JPA: update Document set status = :status where id in :ids (batch update).
   Для истории и реестра — batch insert (например, через saveAll с batch_size в Hibernate и одним flush на пачку), чтобы не открывать отдельную транзакцию на каждый ID.
   Ограничение размера запроса
   На входе API — лимит на длину списка (например, не более 1000 ID за запрос). Для 5000 ID клиент делает 5 запросов или мы вводим «фоновую задачу по заявке» (см. ниже).
   Асинхронная обработка больших объёмов
   Для 5000+ ID не обрабатывать всё в одном HTTP-запросе:
   принять запрос, сохранить «заявку» (список ID, статус: в обработке);
   вернуть клиенту id заявки;
   обрабатывать пачками (например, по 200–500 ID) в отдельном потоке/воркере, обновляя прогресс;
   по завершении — обновить статус заявки; клиент опрашивает статус или получает уведомление.
   Производительность и нагрузка на БД
   Включить/проверить batch-настройки JPA (у вас уже есть order_inserts/order_updates, можно явно задать batch_size под размер пачки).
   Для массового чтения — по возможности без лишних join’ов (например, отдельный запрос только по ID и статусу, без загрузки полной истории в одном запросе).
   При необходимости — разнести чтение и запись по репликам (read replica для отчётов).
   Итого: чтобы «уверенно» держать 5000+ ID в одном логическом запросе — я бы вынес обработку в фоновую задачу с пачками и batch-операциями в БД; в одном синхронном HTTP-запросе оставил бы ограничение (например, до 1000 ID) и тоже перевёл бы реализацию на batch update/insert вместо цикла по одному ID.
2. Вынос реестра утверждений в отдельную систему
   Сейчас: ApprovalRegistry живёт в той же БД, что и документы; при утверждении в одной транзакции обновляется Document и сохраняется запись в реестре.
   Варианты выноса:
   Вариант A: Отдельная БД (тот же сервис, другая БД)
   Отдельная схема/база только для реестра (отдельный DataSource, свои entity/repository).
   В сервисе утверждения: в одной бизнес-операции сначала обновить документ в «документной» БД, затем записать в реестр во второй БД. Сложность — распределённая консистентность: если вторая запись упадёт, документ уже APPROVED, а записи в реестре нет.
   Митигация:
   Локальная транзакция «документы» + outbox: в той же транзакции, где ставим APPROVED, писать в таблицу «события для реестра»; отдельный процесс читает outbox и пишет в БД реестра (с идемпотентностью по id операции).
   Либо принять eventual consistency и иметь фоновую сверку/восстановление записей реестра по данным документов.
   Вариант B: Отдельный HTTP-сервис реестра
   Новый сервис с API вида: POST /registry/approvals (documentId, approvedBy, timestamp, при необходимости — метаданные).
   Document Operator при утверждении: в своей транзакции обновляет документ, затем вызывает HTTP-сервис реестра. Реестр только хранит и отдаёт данные об утверждениях.
   Проблемы:
   Два шага без общей транзакции: документ уже APPROVED, а вызов реестра может упасть или зависнуть.
   Нужна политика повторов и идемпотентность на стороне реестра (например, по documentId или по idempotency key).
   Устойчивость:
   Либо синхронный вызов с retry и чётким контрактом (идемпотентность), либо снова outbox: в транзакции с обновлением документа записываем «событие: документ X утверждён пользователем Y»; отдельный процесс шлёт события в HTTP-сервис реестра. Тогда при падении реестра события не теряются и их можно доставить позже.
   Вариант C: Реестр как «приложение событий»
   Document Operator публикует события (Kafka/RabbitMQ и т.п.): «DocumentApproved(documentId, approvedBy, …)».
   Отдельный сервис (или отдельная БД того же приложения) подписан на эти события и только пишет в реестр. Документы и реестр тогда полностью разделены по данным и по масштабированию.
   Плюсы: развязка, возможность иметь несколько подписчиков, повторная доставка. Минусы: инфраструктура очередей, eventual consistency.
   Что бы я выбрал:
   Если нужна простая изоляция данных и один домен — отдельная БД + outbox из Document Operator в эту БД (или в очередь, а оттуда — в БД реестра).
   Если реестр станет отдельным продуктом/командой или нужен доступ по HTTP из других систем — отдельный HTTP-сервис реестра с идемпотентным API и доставкой событий через outbox (или через брокер), чтобы не терять утверждения при сбоях и не держать распределённые транзакции.
   Общее: при любом выносе реестра я бы не делал «одна транзакция в двух системах», а использовал бы паттерн «зафиксировать решение в своей БД + гарантированно доставить событие в реестр (outbox или очередь)».
